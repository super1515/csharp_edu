# Главные конструкции C# (Часть 1)

## Метод Main()

Метод ``Main`` — это точка входа приложения C#. В программе на C# может существовать только одна точка входа. Метод ``Main`` должен быть помечен ключевым словом ``static``.

При запуске приложения, первым вызывается метод ``Main``. Если в проекте несколько классов с методом ``Main``, программу нужно компилировать с параметром компилятора StartupObject, чтобы указать, какой из методов ``Main`` будет использоваться в качестве точки входа. 

Точку входа можно создавать с любой из сигнатур:
```csharp
static void Main() { }
static int Main() { }
static void Main(string[] args) { }
static int Main(string[] args) { }
```

### Асинхронный метод Main() [C# 7.1]

Метод ``Main`` также может быть асинхронным:
```csharp
static async Task Main() { }
static async Taskint Main() { }
static async Task Main(string[] args) { }
static async Taskint Main(string[] args) { }
```

### Операторы верхнего уровня [C# 9.0]

Точку входа можно задать неявно с помощью операторов верхнего уровня:
```csharp
using System;
Console.WriteLine(Hello, World!);
```
Этот код аналогичен предыдущему:
```csharp
using System;
namespace Application
{
    class Program
    {
        static void Main()
        {
            Console.WriteLine(Hello World!);
        }
    }
}
```
Существует ряд правил использования операторов верхнего уровня:
* Проект может содержать только один файл с операторами верхнего уровня. В проекте с операторами верхнего уровня нельзя использовать параметр компилятора ``-main`` для выбора точки входа, в случае использования нескольких методов Main.
* Директивы ``using`` должны быть записаны до операторов верхнего уровня.
* Операторы верхнего уровня неявно находятся в глобальном пространстве имен.
* Операторы верхнего уровня должны быть записаны до объявлений пространств имен, типов, функций.
* Операторы верхнего уровня могут ссылаться на переменную ``args``

### Аргументы командной строки
Для того чтобы получить аргументы командной строки достаточно определить метод ``Main`` следующим образом:
```csharp
static void Main(string[] args)
{
    ...
}
```
Аргумент ``args`` представляет собой строковый массив.

Другим подходом к получению аргументов командной строки является метод ``GetCommandLineArgs()`` типа ``System.Environment``, который работает с любой сигнатурой метода ``Main``.

## Форматирование

### Форматирование консольного вывода

Платформа .NET представляет возможность указать заполнители консольного вывода:
```csharp
Console.WriteLine("Hello, {1}, {0}{2}{2}", "how are you", "man", "?");
```
Порядковые числа заполнителей всегда начинаются с 0. Заполнители могут располагаться в любом порядке и любое количество раз.

В случае, если уникальных заполнителей больше, чем заполняющих аргументов, то будет выдано исключение. Если меньше - заполняющие аргументы игнорируются.

### Форматирование числовых данных

Для численных данных определены различные символы форматирвания:
Символ | Пример | Описание
--- | --- | ---
"C" или "c" | 500.5 -> $500.5 | Валюта (зависит от культуры)
"D" или "d" | 499 -> 00499 | Минимальное количество разрядов для представления десятичного числа
"E" или "e" | 1052.0329112756 -> 1.052033E+003 | Экспоненциальное представление десятичного числа
"F" или "f" | 1234.567 -> 1234.57 | Представление числа с фиксированной точкой (зависит от культуры)
"G" или "g" | -1.234567890e-25 -> 1,23456789E-25 | Совмещает "E" и "F" (зависит от культуры)
"N" или "n" | 1234.567 -> 1 234 57 | Базовое числовое форматирование (зависит от культуры)
"P" или "p" | 1 -> 100 % | Число, умноженное на 100, с символом % (зависит от культуры)
"R" или "r" | 1234.1234 -> 1234.1234 | Строка, дающая при обратном преобразовании идентичное число
"X" или "x" | 255 -> FF | Шестнадцатеричное число

Символы форматирования можно использовать следующим образом:
```csharp
Console.WriteLine("Сurrency {0:C}, Percentages {1:P}", cur, per);
```
Также существует возможность задать выравнивание. 
Положительное значение после запятой задает выравнивание по правому краю, отрицательное - выравнивание по левому краю. 
Помимо всего прочего, это значение характеризует ширину поля:
```csharp
string s = String.Format("{0,10} {1,-10}\n", "First", "Second");
```

### Форматирование строкового литерала

Для форматирования строки можно воспользоваться статическим методом ``string.Format()``:
```csharp
string str = string.Format("Give me {0:C} now!", 100);
```

## Системные типы данных

В языке C# представлены различные фундаментальные типы данных, которые представлены ниже. 
В таблице также указана совместимость с CLS и полное имя каждого типа данных.
Тип данных | Совместимость CLS | Полное имя | Диапозон значений | Описание
--- | --- | --- | --- | ---
``bool`` | + | ``System.Boolean`` | ``true`` или ``false`` | Истина или ложь
``sbyte`` | - | ``System.SByte`` | От -128 до 127 | 1 байт, со знаком
``byte`` | + | ``System.Byte`` | От 0 до 255 | 1 байт, без знака
``short`` | + | ``System.Int16`` | От -32768 до 32767 | 2 байта, со знаком
``ushort`` | - | ``System.UInt16`` | От 0 до 65535 | 2 байта, без знака
``int`` | + | ``System.Int32`` | От -2147483648 до 2147483647 | 4 байта, со знаком
``uint`` | - | ``System.UInt32`` | От 0 до 4294967295 | 4 байта, без знака
``long`` | + | ``System.Int64`` | От $-2^{63}$ до $2^{63}-1$ | 8 байт, со знаком
``ulong`` | - | ``System.UInt64`` | От 0 до $2^{64}-1$ | 8 байт, без знака
``char`` | + | ``System.Char`` | От U+0000 до U+ffff | 2 байта, символ Unicode
``float`` | + | ``System.Single`` | От $-3.4 * 10^{38}$ до $3.4 * 10^{38}$ | 4 байта, 8 знаков после запятой
``double`` | + | ``System.Double`` | От $\pm5.0 * 10^{-324}$ до $\pm1.7 * 10^{308}$ | 8 байт, 15-16 знаков после запятой
``decimal`` | + | ``System.Decimal`` | От $\pm1.0 * 10^{-28}$ до $\pm7.9228 * 10^{28}$ | 16 байт, 28-29 знаков после запятой
``string`` | + | ``System.String`` | $\inf$ | Набор символов Unicode
``object`` | + | ``System.Object`` | Любой тип | Базовый класс

### Иерархия классов для типов данных

Каждый тип является производным от класса ``System.Object``, для которого определен набор методов, таких как ``ToString()``, ``Equals()``, ``GetHashCode()``.

Также многие числовые типы данных, структуры и перечисления являются производными от класса ``System.ValueType``. Потомки ``System.ValueType`` размещаются в стеке, а не в куче.

### Члены типов данных

#### Члены числовых типовых данных

Для встроенных числовых типов данных определены уникальные свойства ``MinValue`` и ``MaxValue``. 
В добавок, для чисел с плавающей точной определены свойства ``Epsilon``, ``Positivelnfinity``, ``NegativeInfinity``.

```csharp
Console.WriteLine("Min value for int: " + int.MinValue);
Console.WriteLine("Epsilon for float: " + float.Epsilon);
```

#### Члены System.Boolean

Для ``System.Boolean``определены свойства ``TrueString`` и ``FalseString``:

```csharp
Console.WriteLine("True: " + bool.TrueString);
Console.WriteLine("False: " + bool.FalseString);
```

#### Члены System.Char

С помощью статических методов ``IsDigit()``, ``IsLetter()``, ``IsWhiteSpace()``, ``IsPunctuation()`` можно определить является символ цифрой, буквой, пробелом или знаком пунктуации:
```csharp
string str = "5A !";
Console.WriteLine("Digit: " + char.IsDigit(str[0]));
Console.WriteLine("Letter: " + char.IsLetter(str[1]));
Console.WriteLine("White Space: " + char.IsWhiteSpace(str, 2));
Console.WriteLine("Punctuation: " + char.IsPunctuation(str, 3));
```
Можно заметить, что многие статические методы класса ``System.Char`` поддерживают два соглашения о вызове.

#### Методы Parse() и TryParse()

Статические методы ``Parse()`` и ``TryParse()`` преобразовывают строковый летерал в переменную, определенного типа данных:

```csharp
int myFirstInt = int.Parse("1234");
int mySecondInt;
if(int.TryParse("5678", out mySecondInt)) 
    Console.WriteLine("My Second Int: " + mySecondInt);
else 
    Console.WriteLine("My Second Int isnt valid. Default value: " + mySecondInt);
```
В случае, если аргумент метода ``Parse()`` имеет неверный формат, то будет выброшено исключение. 
Для решения этой проблемы можно воспользоваться методом ``TryParse()``, который вернет ``true`` при успешном преобразовании или ``false`` в противном случае.
## Переменные

Для объявления переменной необходимо указать тип данных и имя переменной:

```csharp
int num;
```
Использование переменной до присвоения ей значения приведет к ошибке на этапе компиляции. Присвоить значение переменной можно при объявлении или после него:
```csharp
int first = 1;
int second = 2, third = 3;
string fourth;
fourth = "My string";
```

### Литерал default [C# 7.1]

С помощью литерала ``default`` можно присвоить переменной стандартное значение, специфичное для типа данных:
```csharp
int first = default; // 0
float second = default(float); // 0.0 - до C# 7.1
```

### Операция new [C# 9.0]

Проинициализировать можно также с помощью стандартного конструктора:
```csharp
int first = new int(); // 0
```

C# 9.0 позволяет использовать сокращенную запись:
```csharp
int first = new(); // 0
```

### Типы System.DateTime и System.TimeSpan

Структура ``DateTime`` представляет собой тип данных, характеризующий дату и время, которые могут быть форматированы различнымы способами. Тип ``DateTime`` так же содержит некоторые статические свойства.
```csharp
DateTime dateFirst = new DateTime(); // 1/1/0001 12:00:00 AM
DateTime dateSecond = new DateTime(2008, 3, 1, 7, 0, 0); // 3/1/2008 7:00:00 AM
DateTime date1 = DateTime.Now;
DateTime date2 = DateTime.UtcNow;
DateTime date3 = DateTime.Today;
```
Структура ``TimeSpan`` представляет интервал времени, характеризующийся днями, часами, минутами, секундами и миллисекундами:
```csharp
DateTime dateFirst = new DateTime(2020, 1, 1, 8, 0, 15);
DateTime dateSecond = new DateTime(2020, 8, 18, 13, 30, 30);
TimeSpan interval = dateSecond - dateFirst;
Console.WriteLine("{0} - {1} = {2}", dateSecond, dateFirst, interval.ToString());
Console.WriteLine("{0,-35} {1,20}", "Value of Days Component:", interval.Days);
Console.WriteLine("{0,-35} {1,20}", "Total Number of Days:", interval.TotalDays);
...
Console.WriteLine("   {0,-35} {1,20:N0}", "Value of Milliseconds Component:", interval.Milliseconds);
Console.WriteLine("   {0,-35} {1,20:N0}", "Total Number of Milliseconds:", interval.TotalMilliseconds);
Console.WriteLine("   {0,-35} {1,20:N0}", "Ticks:", interval.Ticks);
```

### Пространство имен System.Numerics

В пространстве имен ``System.Numerics`` существует структура ``BigInteger``. Этот тип данных является неизменяемым, как и строки, и позволяет манипулировать очень большими числовыми значениями, которые не ограничены ни сверху, ни снизу. 

Для него определены простейшие математические операции и некоторые свойства. 
Для инициализации переменной ``BigInteger`` можно воспользоваться статическим метолом ``Parse``:
```csharp
Biglnteger BigFirst = Biglnteger.Parse("123456789123456789123456789");
Console.WriteLine("Value of BigSecond: ", BigFirst);
Console.WriteLine("Even?: {0}", BigFirst.IsEven);
Console.WriteLine("Power of two?: {0}", BigFirst.IsPowerOfTwo);
Biglnteger BigSecond = BigFirst * Biglnteger.Parse("987654321987654321987654321");
Console.WriteLine("Value of BigSecond: ", BigSecond);
```

Помимо всего прочего, в пространстве имен ``System.Numerics`` определена структура ``Complex`` для работы с комплексными числами.

### Разделители групп цифр и двоичные литералы [C# 7.0/7.2]

Разделители групп цифр, появившиеся в C# 7.0, позволяют визуально разделить число на несколько частей. 

Помимо этого, в C# 7.0 появился новый литерал для двоичных значений.

В версии C# 7.2 разрешено начинать двоичные и шестнадцатеричные литералы с символа подчеркивания.
```csharp
Console.WriteLine("Integer:" + 123_456);
Console.WriteLine("Long: " + 123_456_789L);
Console.WriteLine("Float: " + 123_456.1234F);
Console.WriteLine("Double:" + 123_456.12);
Console.WriteLine("Decimal: " = 123_456.12M);
Console.WriteLine("Hex: " + Ox_00_00_FF); // C# 7.2
Console.WriteLine("Hex: " + Ob_0011_0000); // C# 7.2
```
Обратите внимание, по умолчанию литерал целого числа имеет тип ``int``, а число с плавающей точкой тип ``double``. Однако, в примере выше использованы суффиксы, которые позволяют указать компилятору тип данных литерала числа. 
