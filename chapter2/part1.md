# Главные конструкции C# (Часть 1)

## Метод Main()

Метод ``Main`` — это точка входа приложения C#. В программе на C# может существовать только одна точка входа. Метод ``Main`` должен быть помечен ключевым словом ``static``.

При запуске приложения, первым вызывается метод ``Main``. Если в проекте несколько классов с методом ``Main``, программу нужно компилировать с параметром компилятора StartupObject, чтобы указать, какой из методов ``Main`` будет использоваться в качестве точки входа. 

Точку входа можно создавать с любой из сигнатур:
```csharp
static void Main() { }
static int Main() { }
static void Main(string[] args) { }
static int Main(string[] args) { }
```

### Асинхронный метод Main() [C# 7.1]

Метод ``Main`` также может быть асинхронным:
```csharp
static async Task Main() { }
static async Task<int> Main() { }
static async Task Main(string[] args) { }
static async Task<int> Main(string[] args) { }
```

### Операторы верхнего уровня [C# 9.0]

Точку входа можно задать неявно с помощью операторов верхнего уровня:
```csharp
using System;
Console.WriteLine("Hello, World!");
```
Этот код аналогичен предыдущему:
```csharp
using System;
namespace Application
{
    class Program
    {
        static void Main()
        {
            Console.WriteLine("Hello World!");
        }
    }
}
```
Существует ряд правил использования операторов верхнего уровня:
* Проект может содержать только один файл с операторами верхнего уровня. В проекте с операторами верхнего уровня нельзя использовать параметр компилятора ``-main`` для выбора точки входа, в случае использования нескольких методов Main.
* Директивы ``using`` должны быть записаны до операторов верхнего уровня.
* Операторы верхнего уровня неявно находятся в глобальном пространстве имен.
* Операторы верхнего уровня должны быть записаны до объявлений пространств имен, типов, функций.
* Операторы верхнего уровня могут ссылаться на переменную ``args``.

### Аргументы командной строки
Для того чтобы получить аргументы командной строки достаточно определить метод ``Main`` следующим образом:
```csharp
static void Main(string[] args)
{
    ...
}
```
Аргумент ``args`` представляет собой строковый массив.

Другим подходом к получению аргументов командной строки является метод ``GetCommandLineArgs()`` типа ``System.Environment``, который работает с любой сигнатурой метода ``Main``.

## Форматирование

### Форматирование консольного вывода

Платформа .NET представляет возможность указать заполнители консольного вывода:
```csharp
Console.WriteLine("Hello, {1}, {0}{2}{2}", "how are you", "man", "?");
```
Порядковые числа заполнителей всегда начинаются с 0. Заполнители могут располагаться в любом порядке и любое количество раз.

В случае, если уникальных заполнителей больше, чем заполняющих аргументов, то будет выдано исключение. Если меньше - заполняющие аргументы игнорируются.

### Форматирование числовых данных

Для численных данных определены различные символы форматирвания:
Символ | Пример | Описание
--- | --- | ---
"C" или "c" | 500.5 -> $500.5 | Валюта (зависит от культуры)
"D" или "d" | 499 -> 00499 | Минимальное количество разрядов для представления десятичного числа
"E" или "e" | 1052.0329112756 -> 1.052033E+003 | Экспоненциальное представление десятичного числа
"F" или "f" | 1234.567 -> 1234.57 | Представление числа с фиксированной точкой (зависит от культуры)
"G" или "g" | -1.234567890e-25 -> 1,23456789E-25 | Совмещает "E" и "F" (зависит от культуры)
"N" или "n" | 1234.567 -> 1 234 57 | Базовое числовое форматирование (зависит от культуры)
"P" или "p" | 1 -> 100 % | Число, умноженное на 100, с символом % (зависит от культуры)
"R" или "r" | 1234.1234 -> 1234.1234 | Строка, дающая при обратном преобразовании идентичное число
"X" или "x" | 255 -> FF | Шестнадцатеричное число

Символы форматирования можно использовать следующим образом:
```csharp
Console.WriteLine("Сurrency {0:C}, Percentages {1:P}", cur, per);
```
Также существует возможность задать выравнивание. 
Положительное значение после запятой задает выравнивание по правому краю, отрицательное - выравнивание по левому краю. 
Помимо всего прочего, это значение характеризует ширину поля:
```csharp
string s = String.Format("{0,10} {1,-10}\n", "First", "Second");
```

### Форматирование строкового литерала

Для форматирования строки можно воспользоваться статическим методом ``string.Format()``:
```csharp
string str = string.Format("Give me {0:C} now!", 100);
```

## Системные типы данных

В языке C# представлены различные фундаментальные типы данных, которые представлены ниже. 
В таблице также указана совместимость с CLS и полное имя каждого типа данных.
Тип данных | Совместимость CLS | Полное имя | Диапозон значений | Описание
--- | --- | --- | --- | ---
``bool`` | + | ``System.Boolean`` | ``true`` или ``false`` | Истина или ложь
``sbyte`` | - | ``System.SByte`` | От -128 до 127 | 1 байт, со знаком
``byte`` | + | ``System.Byte`` | От 0 до 255 | 1 байт, без знака
``short`` | + | ``System.Int16`` | От -32768 до 32767 | 2 байта, со знаком
``ushort`` | - | ``System.UInt16`` | От 0 до 65535 | 2 байта, без знака
``int`` | + | ``System.Int32`` | От -2147483648 до 2147483647 | 4 байта, со знаком
``uint`` | - | ``System.UInt32`` | От 0 до 4294967295 | 4 байта, без знака
``long`` | + | ``System.Int64`` | От $-2^{63}$ до $2^{63}-1$ | 8 байт, со знаком
``ulong`` | - | ``System.UInt64`` | От 0 до $2^{64}-1$ | 8 байт, без знака
``char`` | + | ``System.Char`` | От U+0000 до U+ffff | 2 байта, символ Unicode
``float`` | + | ``System.Single`` | От $-3.4 * 10^{38}$ до $3.4 * 10^{38}$ | 4 байта, 8 знаков после запятой
``double`` | + | ``System.Double`` | От $\pm5.0 * 10^{-324}$ до $\pm1.7 * 10^{308}$ | 8 байт, 15-16 знаков после запятой
``decimal`` | + | ``System.Decimal`` | От $\pm1.0 * 10^{-28}$ до $\pm7.9228 * 10^{28}$ | 16 байт, 28-29 знаков после запятой
``string`` | + | ``System.String`` | $\inf$ | Набор символов Unicode
``object`` | + | ``System.Object`` | Любой тип | Базовый класс

### Иерархия классов для типов данных

Каждый тип является производным от класса ``System.Object``, для которого определен набор методов, таких как ``ToString()``, ``Equals()``, ``GetHashCode()``.

Также многие числовые типы данных, структуры и перечисления являются производными от класса ``System.ValueType``. Потомки ``System.ValueType`` размещаются в стеке, а не в куче.

### Члены типов данных

#### Члены числовых типовых данных

Для встроенных числовых типов данных определены уникальные свойства ``MinValue`` и ``MaxValue``. 
В добавок, для чисел с плавающей точной определены свойства ``Epsilon``, ``Positivelnfinity``, ``NegativeInfinity``.

```csharp
Console.WriteLine("Min value for int: " + int.MinValue);
Console.WriteLine("Epsilon for float: " + float.Epsilon);
```

#### Члены System.Boolean

Для ``System.Boolean``определены свойства ``TrueString`` и ``FalseString``:

```csharp
Console.WriteLine("True: " + bool.TrueString);
Console.WriteLine("False: " + bool.FalseString);
```

#### Члены System.Char

С помощью статических методов ``IsDigit()``, ``IsLetter()``, ``IsWhiteSpace()``, ``IsPunctuation()`` можно определить является символ цифрой, буквой, пробелом или знаком пунктуации:
```csharp
string str = "5A !";
Console.WriteLine("Digit: " + char.IsDigit(str[0]));
Console.WriteLine("Letter: " + char.IsLetter(str[1]));
Console.WriteLine("White Space: " + char.IsWhiteSpace(str, 2));
Console.WriteLine("Punctuation: " + char.IsPunctuation(str, 3));
```
Можно заметить, что многие статические методы класса ``System.Char`` поддерживают два соглашения о вызове.

#### Методы Parse() и TryParse()

Статические методы ``Parse()`` и ``TryParse()`` преобразовывают строковый летерал в переменную, определенного типа данных:

```csharp
int myFirstInt = int.Parse("1234");
int mySecondInt;
if(int.TryParse("5678", out mySecondInt)) 
    Console.WriteLine("My Second Int: " + mySecondInt);
else 
    Console.WriteLine("My Second Int isnt valid. Default value: " + mySecondInt);
```
В случае, если аргумент метода ``Parse()`` имеет неверный формат, то будет выброшено исключение. 
Для решения этой проблемы можно воспользоваться методом ``TryParse()``, который вернет ``true`` при успешном преобразовании или ``false`` в противном случае.

### Преобразование типов данных

#### Сужающие и расширяющие преобразования

```csharp
using System;
short a = 5, b = 10;
Console.WriteLine($"{a}^2 + {b}^2 = {SumOfSquares(a, b)}");
static int SumOfSquares(int a, int b)
{
    return a*a + b*b;
}
```
Несмотря на то что переменные ``a`` и ``b`` имеют тип данных ``short``, а метод ``SumOfSquares`` принимает два аргумента типа ``int``, программа выполняется без ошибок.

Такое поведение называется неявно `расширяющим` приведением типов. Действительно, диапазон значений ``int`` включен в диапазон ``short``. Такое приведение не может привести к переполнению, поэтому выполняется неявно.

Модифицируем код следующим образом:
```csharp
short ans = SumOfSquares(a, b);
Console.WriteLine($"{a}^2 + {b}^2 = {ans}");
```
Поскольку метод ``SumOfSquares`` возвращает значение ``int``, которое затем записывается в переменную ``short``, компилятор сообщит об ошибке. Диапазон значений ``int`` выходит за пределы диапазона значений ``short``. 

Так как компилятор не может выполнить `сужающую` операцию неявно, можно в явном виде указать потребность приведения типов:
```csharp
short ans = (short) SumOfSquares(a, b);
```
Этот код скомпилируется успешно, но пользователь не будет застрахован от возможного переполнения переменной, и, как следствие, потери данных. Так, например, если переменные `a` и `b` будут иметь значения 20000 и 30000 соотвественно, программа выведет результат 27904, что совершенно неверно.

#### Ключевые слова checked и unchecked

Для избежания переполнения при выполнении арифметических операций существует ключевое слово ``checked``, которым можно пометить оператор или блок операторов:
```csharp
short ans = checked((short) SumOfSquares(a, b));
```
Пометить блок операторов можно следующим образом:
```csharp
short ans;
checked{
    ans = (short) SumOfSquares(a, b);
}
```
В таком случае, при переполнении будет сгенерировано исключение ``System.OverflowException``.

Несмотря на то, что по умолчанию в проектах .NET проверка переполнениия отключена по умолчанию. Проверку переполнения можно установить на уровне проекта, для этого достаточно установить параметр ``CheckForOverflowUnderflow`` в значение ``true``. Однако в некоторых случаях это может привести к потере производительности.

Для того чтобы отметить блок кода, который не следует проверять на переполнение, можно воспользоваться ключевым словом ``unchecked``. 
## Переменные

Для объявления переменной необходимо указать тип данных и имя переменной:

```csharp
int num;
```
Использование переменной до присвоения ей значения приведет к ошибке на этапе компиляции. Присвоить значение переменной можно при объявлении или после него:
```csharp
int first = 1;
int second = 2, third = 3;
string fourth;
fourth = "My string";
```

### Литерал default [C# 7.1]

С помощью литерала ``default`` можно присвоить переменной стандартное значение, специфичное для типа данных:
```csharp
int first = default; // 0
float second = default(float); // 0.0 - до C# 7.1
```

### Операция new [C# 9.0]

Проинициализировать можно также с помощью стандартного конструктора:
```csharp
int first = new int(); // 0
```

C# 9.0 позволяет использовать сокращенную запись:
```csharp
int first = new(); // 0
```

### Неявно типизированные локальные переменные

Язык C# поддерживает возможность `неявной типизации` локальных переменных с использованием ключевого слова ``var``:
```csharp
using System;
var num = 2500;
var anotherNum = 3000;
var str = "Sum of nums: ";
Console.WriteLine(str + (num + anotherNum));
Console.WriteLine($"Types of vars: {num.GetType()}, {anotherNum.GetType()}, {str.GetType()}");
```

При использовании ключевого слова ``var`` компилятор сам позаботится о выборе типа данных переменной на основе ее начального значения. 

Отсюда возникает ряд ограничений применимых к неявно типизированным переменным:
* Неявная типизация может применяться только к локальным переменным внутри области видимости метода или свойства.
* Ключевое слово ``var`` нельзя использовать в определении возвращаемого значения.
* Неявно типизированным переменным обязательно нужно присваивать начальное значение отличное от ``null``.

По существу, неявно типизированная переменная после инициализации является строго типизированной.

Несмотря на все удобства применения ключевого слова ``var``, использовать его в ситуации, когда тип данных заранее очевиден, не рекомендуется. Хорошим примером применения ``var`` является его использование при объявлении запроса LINQ.
### Типы System.DateTime и System.TimeSpan

Структура ``DateTime`` представляет собой тип данных, характеризующий дату и время, которые могут быть форматированы различными способами. Тип ``DateTime`` так же содержит некоторые статические свойства.
```csharp
DateTime dateFirst = new DateTime(); // 1/1/0001 12:00:00 AM
DateTime dateSecond = new DateTime(2008, 3, 1, 7, 0, 0); // 3/1/2008 7:00:00 AM
DateTime date1 = DateTime.Now;
DateTime date2 = DateTime.UtcNow;
DateTime date3 = DateTime.Today;
```
Структура ``TimeSpan`` представляет интервал времени, характеризующийся днями, часами, минутами, секундами и миллисекундами:
```csharp
DateTime dateFirst = new DateTime(2020, 1, 1, 8, 0, 15);
DateTime dateSecond = new DateTime(2020, 8, 18, 13, 30, 30);
TimeSpan interval = dateSecond - dateFirst;
Console.WriteLine("{0} - {1} = {2}", dateSecond, dateFirst, interval.ToString());
Console.WriteLine("{0,-35} {1,20}", "Value of Days Component:", interval.Days);
Console.WriteLine("{0,-35} {1,20}", "Total Number of Days:", interval.TotalDays);
...
Console.WriteLine("   {0,-35} {1,20:N0}", "Value of Milliseconds Component:", interval.Milliseconds);
Console.WriteLine("   {0,-35} {1,20:N0}", "Total Number of Milliseconds:", interval.TotalMilliseconds);
Console.WriteLine("   {0,-35} {1,20:N0}", "Ticks:", interval.Ticks);
```

### Пространство имен System.Numerics

В пространстве имен ``System.Numerics`` существует структура ``BigInteger``. Этот тип данных является неизменяемым, как и строки, и позволяет манипулировать очень большими числовыми значениями, которые не ограничены ни сверху, ни снизу. 

Для него определены простейшие математические операции и некоторые свойства. 
Для инициализации переменной ``BigInteger`` можно воспользоваться статическим метолом ``Parse``:
```csharp
Biglnteger BigFirst = Biglnteger.Parse("123456789123456789123456789");
Console.WriteLine("Value of BigSecond: ", BigFirst);
Console.WriteLine("Even?: {0}", BigFirst.IsEven);
Console.WriteLine("Power of two?: {0}", BigFirst.IsPowerOfTwo);
Biglnteger BigSecond = BigFirst * Biglnteger.Parse("987654321987654321987654321");
Console.WriteLine("Value of BigSecond: ", BigSecond);
```

Помимо всего прочего, в пространстве имен ``System.Numerics`` определена структура ``Complex`` для работы с комплексными числами.

### Разделители групп цифр и двоичные литералы [C# 7.0/7.2]

Разделители групп цифр, появившиеся в C# 7.0, позволяют визуально разделить число на несколько частей. 

Помимо этого, в C# 7.0 появился новый литерал для двоичных значений.

В версии C# 7.2 разрешено начинать двоичные и шестнадцатеричные литералы с символа подчеркивания.
```csharp
Console.WriteLine("Integer:" + 123_456);
Console.WriteLine("Long: " + 123_456_789L);
Console.WriteLine("Float: " + 123_456.1234F);
Console.WriteLine("Double:" + 123_456.12);
Console.WriteLine("Decimal: " = 123_456.12M);
Console.WriteLine("Hex: " + Ox_00_00_FF); // C# 7.2
Console.WriteLine("Binary: " + Ob_0011_0000); // C# 7.2
```
Обратите внимание, по умолчанию литерал целого числа имеет тип ``int``, а число с плавающей точкой тип ``double``. Однако, в примере выше использованы суффиксы, которые позволяют указать компилятору тип данных литерала числа. 

## Работа со строками

### Члены строк
В классе ``System.String`` определены члены, некоторые из них приведены ниже:

Член | Описание
--- | ---
``Length`` | Свойство, возвращает длину строки
``Compare()`` | Статический метод, сравнивает две строки
``Contains()`` | Метод, определяет наличие подстроки в строке
``Equals()`` | Метод, определяет наличие одинаковых символьных данных
``Format()`` | Статический метод, формирует строку из различных данных
``Insert()`` | Метод, вставляет строку внутрь исходной строки
``PadLeft()`` | Метод, дополняет строку слева определенными символами
``PadRight()`` | Метод, дополняет строку справа определенными символами
``Remove()`` | Метод, удаляет определенное количество символов в строке
``Replace()`` | Метод, изменяет определенное количество символов в строке
``Split()`` | Метод, возвращает подстроки, разделенные определенными символомами
``Trim()`` | Метод, удаляет все вхождения набора символов с начала и конца текущей строки
``ToUpper()`` | Метод, возвращает исходную строку в верхнем регистре
``ToLower()`` | Метод, возвращает исходную строку в нижнем регистре

### Конкатенация строк

Операция соединения строк называется конкатенацией. Для ее выполнения можно воспользоваться оператором ``+`` или статическим методом ``String.Concat()``, что является равносильным:
```csharp
string first = "My TODO list:\n";
string second = "1. Do homework\n";
string third = "2. Play video games" + Environment.NewLine;
string listTODO = first + second + third;
Console.WriteLine(listTODO);
Console.WriteLine(string.Concat("A list of what I'm doing now:\n", third.Replace("2", "1")));
```
Обратите внимание, символ начала строки может отличаться в разных средах выполнения, для избежания ошибок форматирования имеет смысл воспользоваться свойством ``Environment.NewLine``.

### Управляющие последовательности

В языке C# представлен ряд литералов, обозначающих управляющие последовательности:

Литерал | Описание
--- | ---
``\'`` | Символ одинарной кавычки
``\"`` | Символ двойной кавычки
``\\`` | Символ обратной косой черты
``\a`` | Звуковой сигнал
``\n`` | Символ новой строки
``\r`` | Символ возврата каретки
``\t`` | Символ горизонтальной табуляции

### Интерполяция строк

Наряду со стандартным подходом к форматированию строк, существует также альтернативный синтаксис, который называется интерполяцией строк. При таком подходе нет необходимости использовать метод ``string.Format()`` и передавать переменные в виде аргументов функции:
```csharp
string myName = "Nick";
string helloString = $"Hello, {myName.ToUpper()}!";
Console.WriteLine($"Greeting: \"{helloString}\"");
```

Обратите внимание, представленный синтаксис требует наличия символа ``$`` перед строковым литералом.

### Дословные строки

Если написать перед строковым литералом символ ``@``, то такой литерал будет использован дословно. Это означает, что в литерале нельзя использовать управляющие последовательности и строка будет представлена в том виде, в каком она есть:
```csharp
string path = @"C:\Program Files\IIS";
Console.WriteLine(@$"Path to folder: 
    ""{path}""");
```

Заметьте, для представления символа двойной кавычки необходимо ее продублировать, а также следует заметить, что в дословных строках пробельные символы отображаются в том виде, в котором они есть. 

Как видно из примера выше, префиксы ``@`` и ``$`` можно комбинировать, начиная с C# 8 их порядок следования не имеет значения.

### Сравнение строк

Как известно, тип ``string`` является ссылочным и его объекты размещаются в управляемой куче со сборкой мусора. Несмотря на это, операция сравнения строк ``==`` и ``!=`` и метод ``Equals()`` переопределены так, чтобы происходило сравнение не ссылок, а значений:
```csharp
string helloString = "hello";
Console.WriteLine(helloString == "hello");
Console.WriteLine(helloString.Equals("hello"));
```
Для того чтобы произвести различное сравнение строк без учета регистра или культуры достаточно воспользоваться перегруженными версиями ``Equals()``, ``IndexOf()``
или статическим методом ``string.Compare()``. В качестве аргумента методов следует указать перечисление ``StringComparison``:
```csharp
string first = "first";
string second = "Second";
Console.WriteLine(first.Equals(second, StringComparison.CurrentCultureIgnoreCase));
Console.WriteLine(first.IndexOf("i", StringComparison.InvariantCultureIgnoreCase));
Console.WriteLine(string.Compare(first, second, StringComparison.CurrentCulture));
```
В приведенном примере метод ``IndexOf()`` возвращает позицию в строке первого вхождения указанного символа или -1 в случае его отсутствия. 

Метод ``string.Compare()`` сравнивает две строки и возвращает целое число, которое показывает их относительное положение в порядке сортировки или 0 в случае их равенства. 

### Неизменяемость строк

После присвоения объекту ``string`` начального значения символьные данные не могут быть изменены. В результате присвоения результата конкатенации или иной операции значение результирующей строки не присваивается переменной, а присваивается лишь ссылка на копию переменной в измененном виде.

Так, например, в момент, когда происходит присвоение значения переменной, новый объект ``string`` загружается в управляемую кучу, а старый через некоторое время должен быть удален.

Использование ``string`` может оказаться неэффективным и привести к значительному росту загрузки памяти и процессорного времени в результате активной работы сборщика мусора.

### Использование StringBuilder

В связи с неизменяемой сущностью строк, в пространстве имен ``System.Text`` определен класс ``StringBuilder``, отличительной особенностью этого класса является то, что при вызове членов производится изменение внутренних символьных данных без полученая копии данных в модифицированном виде.

Для того чтобы проинициализировать переменную типа ``StringBuilder`` необходимо вызвать один из его конструкторов. Для дальнейшей модификации переменной можно воспользоваться ее членами:
```csharp
using System;
using System.Text;
StringBuilder shopList = new ("Shopping list:" + Environment.NewLine);
shopList.AppendLine("1) Milk");
shopList.AppendLine("2) Tomatoes");
shopList.AppendLine("3) Potatoes");
shopList.Replace("Milk", "Beer");
shopList.Append("Buy it ASAP!");
Console.WriteLine(shopList);
shopList.Clear();
```
По умолчанию объект ``StringBuilder`` хранит 16 символов или меньше, однако это количество автоматически увеличивается по мере необходимости. Значение по умолчанию можно изменить добавив дополнительный аргумент в конструкторе.

## Итерационные конструкции
